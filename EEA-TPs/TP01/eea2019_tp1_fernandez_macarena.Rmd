---
title: "Trabajo Práctico N°1 ^[El código exhibido en este trabajo se encuentra disponible en [este repositorio de GitHub](https://github.com/aladaspalabras/EEA2019)]"
author: "Macarena Fernandez Urquiza"
output: 
  html_notebook:
    toc: true
    toc_float: true
    depth: 2
---

<style type="text/css">
div.main-container {
  max-width: 1600px;
  margin-left: auto;
  margin-right: auto;
}
body {
text-align: justify}
</style>

En primer lugar, se importan las librerías con las que se trabajará: tidyverse, data.table, corrr, ggplot2, GGally y hrbtthemes.

```{r, message=FALSE, warning=FALSE}
library(tidyverse)
library(data.table)
library(corrr)
library(ggplot2)
library(GGally)
library(hrbrthemes)
```


## 1. Preparación de los datos (I)

### 1.1. Carga del dataset

Como primer paso en la preparación de los datos, se procede a cargar el dataset con la función _fread_ de la librerría _data.table_ y se lo asigna a una variable.

A continuación se puede observar que este dataset consta de 388891 registros y 24 columnas.

```{r}
dataset = fread("ar_properties.csv")

dataset
```

Con el fin de conocer un poco mejor su estructura, se emplea la función _summary_ de R base para ver qué tipo de información contiene cada columna.

Aquí se puede apreciar que, de los 24 atributos, 15 contienen información de tipo "caracter"; 8, de tipo "numérico" y uno contiene solamente _missing values_ (l6). 

De aquellos atributos numéricos, se obtienen también las medidas de posición (media, mediana, primer cuartil, tercer cuartil, mínimo y máximo) y la cantidad de datos faltantes (NAs).

```{r}
summary(dataset)
```

Dado que se observa una gran cantidad de atributos categóricos, se utiliza la función _glimpse_ de la librería Tidyverse, que permite visualizar de modo general qué valores contiene cada atributo

```{r}
glimpse(dataset)
```

De lo observado, se puede realizar la siguiente descripción:

 - id: número de identificación de la propiedad. Atributo nominal.
 - ad_type: posiblemente tipo de anuncio. Atributo nominal.
 - start_date: fecha de inicio (del anuncio, posiblemente). Atributo ordinal.
 - ent_date: fecha de finalización (del anuncio, posiblemente). Atributo ordinal.
 - created_on: fecha de creación. Atributo ordinal. 
 - lat: latitud donde se encuentra la propiedad. 
 - longitud: longitud donde se encuentra la propiedad. Atributo numérico.
 - l1: país donde se encuentra la propiedad. Atributo nominal.
 - l2: provincia (si es CABA, se indida "Capital Federal") o región (si es GBA) donde se encuentra la propiedad. Atributo nominal. 
 - l3: ciudad, partido (si es GBA) o barrio (si es CABA) donde se encuentra la propiedad. Atributo nominal.
 - l4: barrio (si es GBA) donde se encuentra la propiedad. Atributo nominal.
 - l5: mayores especificaciones sobre el barrio. Atributo nominal.
 - l6: NA.
 - rooms: cantidad de habitaciones que posee la propiedad. Atributo numérico.
 - bedrooms: cantidad de dormitorios que posee la propiedad. Atributo numérico.
 - bathrooms: cantidad de baños que posee la propiedad. Atributo numérico.
 - surface_total: superficie total de la propiedad. Atributo numérico.
 - surface_covered: superficie cubierta de la propiedad. Atributo numérico.
 - price: precio de la propiedad. Atributo numérico.
 - currency: moneda en la cual se expresa el precio. Atributo nominal.
 - price_period: período que comprende el precio de la propiedad. Atributo nominal.
 - title: título del anuncio. Atributo nominal.
 - property_type: tipo de propiedad. Atributo nominal.
 - operation_type: tipo de operación. Atributo nominal.

### 1.2. Filtrado del dataset

Dado que solo se trabajará con las propiedades en venta que correspondan a casas, departamentos o PHs que se encuentren ubicados en Capital Federal (Argentina) y cuyo precio se encuentre expresado en dólares (USD), se procede a filtrar del dataset para que muestre los registros deseados.

Para ello se utiliza la función _filter_ del paquete dplyr importado junto a tidyverse.

Asimismo, se emplea la función _select_ del mismo paquete para seleccionar los atributos de interés para este trabajo: id, l3, rooms, bedrooms, bathrooms, surface_total, surface_covered, price y property_type.

Se obtiene una dataset de 61905 registros y 9 atributos. Se lo asigna a una nueva varibale.

```{r}
dataset_filtrado <- dataset %>% 
  filter(l1 == 'Argentina',
         l2 == 'Capital Federal',
         currency == 'USD',
         property_type %in% c('Departamento','PH','Casa'),
         operation_type == 'Venta') %>% 
  select(id, l3, rooms, bedrooms, bathrooms, surface_total, surface_covered, price, property_type)

dataset_filtrado
```

## 2. Análisis exploratorio (I) {#analisisi}

### 2.1. Valores únicos y faltantes

En un primer análisis exploratorio, se verifica la cantidad de valores faltanres y de valores únicos en cada atributo.

Para obtener la cantidad de valores únicos se utiliza la función *summarise_all* de paquete dplyr que permite aplicar una misma función a todas las columnas del dataset. En este caso, se le aplica la función *n_distinct* que devuelve la cantidad de valores distintos en cada atributo.

```{r}
unique_values <- dataset_filtrado %>% 
  summarise_all(n_distinct)

unique_values
```

En el caso de los valores faltantes, se aplica la función _is.na_ de R base sobre el dataset filtrado para obtener una máscara booleana que inddica si en cada celda hay un NA o no. Luego, por columna, se suman las filas que sí tienen un NA (que resultaron TRUE para la función aplicada). Para una mejor visualización, se transpone la información obtenida y se la muestra en un data frame.

```{r}
na_values <- dataset_filtrado %>% 
  is.na() %>% 
  colSums() %>% 
  t() %>% 
  as.data.frame()

na_values
```

### 2.2. Correlación entre variables

Con el propósito de cotejar si existe alguna correlación entre la variables numéricas, se realiza una matriz de correlación de las mismas y se la grafica con la función _rplot_ del paquete ggplot2.

Para calcular la correlación se utiliza el coeficiente de correlación de Pearson y se toman en cuenta solamente los registros completos. Esto último se realiza mediante el parámetro "complete.obs".

```{r}
dataset_filtrado %>% 
  select_if(is.numeric) %>% 
  correlate(use="complete.obs") %>% 
  shave() %>% 
  fashion()
```

```{r}
dataset_filtrado %>% 
  select_if(is.numeric) %>% 
  correlate(use="complete.obs")  %>% 
  rplot(colours = c('#003366','#3399FF','#FF3300')) +
  geom_point(size=5) +
  labs(title = 'Correlograma de variables') +
  theme(axis.text.x = element_text(angle = 45, hjust=1))
help(rplot)
```

## 3. Preparacion de los datos (II) {#preparacionii}

El análisis exploratorio realizado en [el apartado anterior](#analisisi) se halló que las variables _bedrooms_ y _rooms_ presentan una alta correlacionadas positiva (con un valor de 0.92). Esto significa que cuando los valores de una aumentan, los de la otra también lo hacen. De este modo, la información que ofrecen es, en cierto sentido, redundante. Esto permite optar por remover una de dichas variables.

Debido a que _bedrooms_ demostró tener gran cantidad de valores faltantes, se quita esta variable del dataset.

Para no tener mayores inconvenientes con el resto de los registros, se decide asimismo quitar aquellos que contengan valores faltantes, preservando solamente los registros completos.

Como resultado, se obtiene un dataset con 8 variables y 51210 registros.

```{r}
dataset_sin_NA <- dataset_filtrado %>% 
  select(-c(bedrooms)) %>% 
  na.omit()

dataset_sin_NA
```

## 4.Análisis exploratorio (II)

Se realiza un nuevo análisis exploratorio, ahora sobre la variable _price_(precio) del dataset sin faltantes, obtenido en [la sección 3](#preparacionii).

Tambié se grafica un nuevo correlograma con las variables actuales.

### 4.1. Medidas de posición y dispersión
 - a) Obtener estadísticas descriptivas para la variable precio (cuartiles, promedio, mínimo y máximo) y realizar un histograma de la variable.
 
```{r}
dataset_sin_NA %>% 
  select(price) %>% 
  summary()
```

### 4.2. Gráficos


```{r}
# basic histogram
dataset_sin_NA %>% 
  ggplot(aes(x=price)) + 
  geom_histogram(fill="#69b3a2", color="#e9ecef", bins = 227, binwidth = 26429) + 
  #ggtitle("Histograma de precios") + 
  labs(title='Histograma de precios',
       x = 'Precios (USD)',
       y = 'Frecuencia') +
  theme_minimal()
```

```{r}
count(dataset_sin_NA, price) %>% 
  mutate(frec = n/nrow(dataset_sin_NA)*100) %>% 
  arrange(desc(frec)) %>% 
  mutate(frec_acum = cumsum(frec))
```


 - b) Obtener estadísticas descriptivas para la variable precio (cuartiles, promedio, mínimo y máximo) por cada tipo de propiedad.
 
```{r}
dataset_sin_NA %>% 
  group_by(property_type) %>% 
  summarise(Q1 = quantile(x = price, probs = 0.25, names = FALSE), 
            Q3 = quantile(x = price, probs = 0.75, names = FALSE), 
            promedio = mean(price), 
            mín = min(price), 
            máx = max(price))
```

 - c) Realizar un gráfico de boxplot de la variable precio por tipo de propiedad.

Primero cambio las variables nominales a numerales discretas.

```{r}
ggdata <- dataset_sin_NA %>% 
  mutate(id = as.factor(id),
         l3 = as.factor(l3),
         property_type = as.factor(property_type))

ggplot(ggdata, aes(x = property_type, y = price, group = property_type, fill = property_type)) +
  geom_boxplot() +
  labs(title='Precio por tipo de propiedad',
       x = 'Tipos de propiedad',
       y = 'Precio (USD)')

# El boxplot no es una buena indicación de outliers
#scale_y_continuous(limits = c(5000, 2000000))
```

 - d) Realizar un correlagrama usando GGAlly.

```{r}
dataset_sin_NA %>% 
  select_if(is.numeric) %>%
  ggcorr(method = c("complete.obs","pearson"),
         low = '#e0f3db',
         mid = '#a8ddb5',
         high = '#43a2ca',
         label = TRUE,
         label_color = "black",
         nbreaks = 5,
         hjust = 0.75,
         legend.position = "left") +
  labs(title = "Propiedades en venta en CABA - Correlograma")
```

## 5. Outliers

 - Eliminar los outliers de la variable precio con algún criterio que elijan: puede ser por valores de corte, eliminar el x% a izquierda y derecha,etc.
 
```{r}
sort(dataset_sin_NA$price, decreasing = FALSE) %>% 
  plot(main = "Scatterplot de precios",
       ylab = "Precios",
       col = "#43a2ca")
```

```{r}
# OPCIÓN #1

dataset_sin_outliers <- dataset_sin_NA %>%
  filter(price < 3500000)

```

```{r}
dataset_sin_outliers %>% 
  select(price) %>% 
  summary()
```

```{r}
dataset_sin_outliers %>% 
  ggplot(aes(x=price)) + 
  geom_histogram(fill="#69b3a2", color="#e9ecef", bins = 200) + 
  #ggtitle("Histograma de precios") + 
  labs(title='Histograma de precios',
       x = 'Precios (USD)',
       y = 'Frecuencia') +
  theme_minimal()
```

```{r}
ggdata_sin_out <- dataset_sin_outliers %>% 
  mutate(id = as.factor(id),
         l3 = as.factor(l3),
         property_type = as.factor(property_type))

ggplot(ggdata_sin_out, aes(x = property_type, y = price, group = property_type, fill = property_type)) +
  geom_boxplot() +
  labs(title='Precio por tipo de propiedad',
       subtitle = 'Valores atípicos removidos',
       x = 'Tipos de propiedad',
       y = 'Precio (USD)')
```

```{r}
# OPCIÓN #2

data.riq <- IQR(dataset_sin_NA$price)
data.riq

cuantiles<-quantile(dataset_sin_NA$price, c(0.25, 0.5, 0.75), type = 7)
cuantiles

outliers_min<-as.numeric(cuantiles[1])-1.5*data.riq
print(outliers_min)

outliers_max<-as.numeric(cuantiles[3])+1.5*data.riq
print(outliers_max)

dataset_sin_outliers2 <- dataset_sin_NA %>% 
  filter(price > outliers_min,
         price < outliers_max)
```


## 6. Análisis exploratorios (III)

 - Repetir los 4 análisis exploratorios realizados en el punto 4 y realizar unos breves comentarios sobre los cambios que encontraron.

```{r}
dataset_sin_outliers2 %>% 
  select(price) %>% 
  summary()
```

```{r}
dataset_sin_outliers2 %>% 
  ggplot(aes(x=price)) + 
  geom_histogram(fill="#69b3a2", color="#e9ecef",bins = 100) + 
  #ggtitle("Histograma de precios") + 
  labs(title='Histograma de precios',
       x = 'Precios (USD)',
       y = 'Frecuencia') +
  theme_minimal()
```

```{r}
count(dataset_sin_outliers2, price) %>% 
  mutate(frec = n/nrow(dataset_sin_outliers2)*100) %>% 
  arrange(desc(frec)) %>% 
  mutate(frec_acum = cumsum(frec))
```
```{r}
dataset_sin_outliers2 %>% 
  group_by(property_type) %>% 
  summarise(Q1 = quantile(x = price, probs = 0.25, names = FALSE), 
            Q3 = quantile(x = price, probs = 0.75, names = FALSE), 
            promedio = mean(price), 
            mín = min(price), 
            máx = max(price))
```

```{r}
ggdata_sin_out2 <- dataset_sin_outliers2 %>% 
  mutate(id = as.factor(id),
         l3 = as.factor(l3),
         property_type = as.factor(property_type))

ggplot(ggdata_sin_out2, aes(x = property_type, y = price, group = property_type, fill = property_type)) +
  geom_boxplot() +
  labs(title='Precio por tipo de propiedad',
       subtitle = 'Valores atípicos removidos',
       x = 'Tipos de propiedad',
       y = 'Precio (USD)')
```

```{r}
dataset_sin_outliers2 %>% 
  select_if(is.numeric) %>%
  ggcorr(method = c("complete.obs","pearson"),
         low = '#e0f3db',
         mid = '#a8ddb5',
         high = '#43a2ca',
         label = TRUE,
         label_color = "black",
         nbreaks = 5,
         hjust = 0.75,
         legend.position = "left") +
  labs(title = "Propiedades en venta en CABA - Correlograma",
       subtitle = "Valores atípicos removidos")
```

## 7. Modelo lineal

 - a) Realizar un modelo lineal simple para explicar el precio en función de las habitaciones (rooms) y otro modelo que explique el precio en función de la superficie total (surface_total)

```{r}

```

 - b) Usar la función summary() para obtener informacion de ambos modelos. Explicar los valores de los coeficientes estimados.
 
```{r}

```
 
 - c) ¿Cuál modelo usarían para predecir el precio? ¿Por qué?