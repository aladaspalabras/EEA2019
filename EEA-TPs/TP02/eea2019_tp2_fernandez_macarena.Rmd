---
title: "Trabajo Práctico N°2^[El código fuente de este trabajo se encuentra disponible  [aquí](https://github.com/aladaspalabras/EEA2019/tree/master/EEA-TPs/TP01).]"
author: "Macarena Fernandez Urquiza"
output: 
  html_notebook:
    toc: true
    toc_float: true
    depth: 3
---

<style type="text/css">
div.main-container {
  max-width: 1600px;
  margin-left: auto;
  margin-right: auto;
}
body {
text-align: justify}
h1{
  font-size: 19pt
}
h2{
  font-size: 17pt
}
h3{
  font-size: 15pt
}
</style>

```{r, warning=FALSE}
library(tidyverse)
library(OneR)
library(broom)
```

# 1. Regresión Lineal Múltiple

## 1.1. Creación del modelo
Se carga un dataset de propiedades.

```{r}
properties <- read_rds('ar_properties.rds')
```

Éste cuenta con 8 variables:

- _id_
- _l3_ (barrio en el que se ubica la propiedad)
- _rooms_  (cantidad de habitaciones)
- _bathrooms_ (cantidad de baños)
- *surface_total* (superficie total)
- *surface_covered* (superficie cubierta)
- _price_ (precio)
- *property_type* (tipo de propiedad)

Exceptuando la variable _id_ que contiene valores únicos con el fin de identificar las propiedades,
se crea un modelo de Regresión Lineal Múltiple para predecir el precio de cada propiedad a partir de las covariables restantes.

```{r}
modelo <- lm(price ~ l3 + rooms + bathrooms + surface_total + surface_covered + property_type,
            data=properties)

length(unique(properties$l3))
summary(modelo)
```

## 1.2. Análisis del modelo

### 1.2.1. Interpretación de los coeficientes estimados

Según este modelo, -109406.61 es la ordenada al origen. Esto significa que, si encontrásemos una propiedad en la que todas las variables tuviesen un valor igual a 0, el modelo predeciría que dicha propiedad tendría un precio de -109406.61.

El resto de los coeficientes indica cómo varía, según la predicción de nuestro modelo, dicho precio inicial al aumentar en una unidad la variable en cuestión.

En el caso de las variables _l3_ y *property_type*, nos encontramos ante variables dummies, variales categóricas que indican que la propiedad tiene cierta cualidad o no. _l3_ se refiere al barrio donde se ubica la propiedad y *property_type*, al tipo de propiedad en que consiste (PH o departamento).

Dado que una propiedad no puede encontrarse en más de un lugar ni ser de más de un tipo, solo uno de los coeficientes para la variable _l3_ y uno para la variable *property_type* tendrá influencia en la predicción que realice nuestro modelo para cada propiedad. Por ejemplo, en el caso de un departamento de Caballito, nuestro modeo utilizará el coeficiente 6220.15 para la variable _l3_ y el coefciente 92653.32 para *property_type*. El resto de los coeficientes relacionados a _l3_ y a *property_type* no se utilizarán dado que la variable reflejará un valor igual a 0 en dichos casos, dejándolos anulados. 

En particular, se observa que los barrios de Puerto Madero, Las Cañitas, Belgrano, Palermos, Recoleta, Núñez, Barrio Norte, Coghlan, Colegiales, Villa Urquiza, Retiro, Saavedra, Villa Ortúzar, Villa Devoto, Chacarita, Pueyrredń, Caballito, Parque Chas, Villa Crespo y Agronomía influirán positivamente en el precio estimado por el modelo puesto que sus coeficientes son positivos. El resto de los barrios, en cambio, presenta un coeficiente negativo por lo que el valor estimado presentará un decremento si la propiedad se encuentra ubicada en uno de ellos.

Las variables _rooms_, _bathrooms_, *surface_total* y *surface_covered*, por otro lado, son numéricas, y pueden tomar cualquier valor. La multiplicación de sus valores por sus respectivos coeficientes también tendrá un impacto en la predicción de nuestro modelo, ya sea generando un aumento en el precio, en el caso de los baños, la superficie total y la superficie cubierta, o ya sea provocando una disminución, en el caso de los dormitorios.

### 1.2.2. Significatividad de las variables dummies

Resulta interesante destacar que, a excepeción de los barrios de Agronomía, Almagro, Barracas, Caballito, Monte Castro, Parque Chas, San Telmo, Villa Crespo, Villa del Parque, Villa Luro, Villa Real y Santa Rita, los valores de la variable dummy _l3_ y *property_type* presentan un *p-valor* menor a 0.05, lo que significa que la variable es útil para explicar _y_ cuando en el modelo se encuentran presentes las demás variables, pero no en otro caso.

Los coeficientes calculados para Agronomía y Villa Crespo, por su parte, muestran un valor mayor a 0.75, indicando que en estos casos la variable resulta significativa incluso en ausencia de las demás variables.

### 1.2.3. Evaluación del modelo

Respecto de la evaluación del modelo, podemos ver que este presenta un R² de 0.77, lo que indica que nuestro modelo es capaz de explicar el 77% de la variabilidad de la variable depediente _y_ a partir de las variables independientes proporcionadas.

## 1.3. Predicciones

A continuación, se proponen dos nuevos casos y se utiliza el modelo ajustado para predecir sus precios.

El primer caso consiste en un departamento de 120 metros cuadrados cubiertos, ubicado en el barrio de Abasto, con 3 dormitorios y 2 baños. El segundo se trata de un PH en Balvanera, con 80 metros cuadrados cubiertos, 20 metros cuadrados no cubiertos, 2 dormitorios y 3 baños.

Se genera un nuevo dataset con estos casos y se utiliza la funció _predict_ para predecir sus precios.

```{r}
nuevos_casos <- data.frame(
  l3 = c('Abasto', 'Balvanera'),
  rooms = c(3, 2),
  bathrooms = c(2, 3),
  surface_total = c(120, 100),
  surface_covered = c(120, 80),
  property_type = c('Departamento', 'PH') 
)

nuevos_casos %>% 
  mutate(predict = predict(modelo, newdata = .)) %>% 
  select(l3, predict, everything())
```

El modelo predice que la propiedad en el barrio de Abasto vale 324596.4, mientras que la del barrio de Balvanera cuesta 215267.6, por lo que resulta preferible tener la primera para vender.

## 1.4. Creación de un nuevo modelo

Se crea un nuevo modelo sin la variable _l3_.

```{r}
modelo_sin_l3 <- lm(price ~ rooms + bathrooms + surface_total + surface_covered + property_type,
                   data=properties)

summary(modelo_sin_l3)
```

Se observa que este modelo presenta una mayor cantidad de residuos. Si bien el número observado es menor (-9643) que en el modelo anterior (-3307), lo deseable es que la media y/o mediana de los residuos se acerque a 0.

Por otro lado, si bien los coeficientes estimados han variado su valor, no han cambiado su signo, por lo que su incidencia en la estimación de precios se mantiene: aquellas variables que incrementaban el valor de los precios continuan haciéndolo y lo mismo ocurre con las que disminuían este valor.

Finalmente, se puede que este segundo modelo posee una menor capacidad explicativa de la variable _y_. Su R² nos indica que las variables independientes solo pueden explicar el 68% de la variable dependiente. Este decremento podría resultar esperable en tanto este modelo utiliza menos variables. Los modelos de Regresión Lineal aumentan su R² conforme aumentan la cantidad de variables empleadas en la predicción, sin importar si estas están o no correlacionadas con la variable a predecir. Sin embargo, si observamos el R² ajustado, vemos que también aquí el primer modelo supera al segundo (77% contra 68%). Esto resulta relevante puesto que el R² ajustado indica la capacidad de explicación de un modelo considerando las variables independientes que sí se encuentran relacionadas con la dependiente. Esta medida disminuya al añadir variables no relacionadas y aumneta solo si las variables agregadas son efecitvamente explicativas. Debido a esto, el R² ajustado posibilita la comparación de modelos con distinta cantidad de variables y será el que utilizaremos para determinar qué modelo explica mejor la variable precios.

## 1.5. Comparación de modelos

El modelo que mejor explica la variable precios es el modelo que incluye la variable _l3_, dado que su R² ajustado. El modelo sin esta variable presenta una menor capacidad de explicación, solo el 68% de la variabilidad de la variable dependiente.

# 2. Creación de variables

## 2.1. Variable _barrios_

Grafico los precios de los barrios para evaluar si hay puntos de quiebre claros:

```{r}
plot(sort(properties$price, decreasing = FALSE),
     main  = 'Precios ordenados en forma creciente',
     ylab = 'Precios',
     xlab = 'Índice',
     col = 'cyan4')
```

No lo hay. Se generan 3 bins y se establecen los puntos de corte a partir de ellos.

```{r}
precios <- properties %>% 
  select(l3, price) %>% 
  group_by(l3) %>% 
  summarise(media_precio = mean(price)) %>% 
  arrange(media_precio)

precios
```


```{r}
precios$bins <- bin(precios$media_precio, 
                    nbins=3, 
                    labels=c("bajo", "medio", "alto"), 
                    method="content")

precios$clusters <- bin(precios$media_precio,
                        nbins=3, 
                        labels=c("bajo", "medio", "alto"), 
                        method="clusters")

precios
```

```{r}
precios %>% 
  count(bins)

precios %>% 
  count(clusters)
```
El de clusters no está tan bien balanceado. Uso el de contents.

```{r}
properties_barrios <- left_join(properties, precios[,c('l3', 'bins')], by='l3')
names(properties_barrios)[names(properties_barrios) == 'bins'] <- 'barrios'

properties_barrios
```

## 2.2. Modelo con variable _barrios_

Se calcula un nuevo modelo.

```{r}
model_con_barrios <- lm(price ~ rooms + bathrooms + surface_total + surface_covered +
                          property_type + barrios, data=properties_barrios)

summary(model_con_barrios)
```
Interpretación de los resultados.

Mejor modelo: con l3 por R cuadrado ajustado
En mi opinión: el de barrios es más útil

## 2.3. Variable *surface_patio*

Chequeo si hay valores en sup total que sean menores a sup cubierta

```{r}
properties_barrios[properties_barrios$surface_covered > properties_barrios$surface_total,]
```

No los hay. De haberlos habido, hubiese tomado como que no hay patio.

```{r}
properties_barriosYpatio <- properties_barrios %>% 
  mutate(surface_patio = surface_total-surface_covered)

properties_barriosYpatio[properties_barriosYpatio$surface_patio<0,]

properties_barriosYpatio
```

## 2.4. Modelo con la variable *surface_patio*

Se entrena un nuevo modelo

```{r}
modelo_barriosYpatio <- lm(price ~ barrios + rooms + bathrooms + surface_covered + surface_patio +
                          property_type, data=properties_barriosYpatio)

summary(modelo_barriosYpatio)
```
surface_patio: mismo coeficiente que surface_total...

# 3. Evaluación de modelo

Analizar los residuos del modelo elaborado en 2.d

## 3.1. Modelo alternativo

Comparar la performance del modelo de 2.d con éste, tanto en términos de la variabilidad explicada cómo de su relación con los supuestos del modelo lineal. Re-interpretar los parámetros del modelo.

```{r}
model_log = lm(price ~ log(rooms) + log(bathrooms) + log(surface_covered) + property_type + 
                 barrios + surface_patio, data=properties_barriosYpatio)

summary(model_log)
```

# 4. Modelos por tipo de propiedad

Anido el dataframe por la variable *property_type*.

```{r}
propTypes <- properties_barriosYpatio %>% 
  group_by(property_type) %>% 
  nest()

propTypes
```

Para cada tipo de propiedad, genero el modelo de 2d

```{r}
patio_model <- function(df) {
  lm(price ~ barrios + rooms + bathrooms + surface_covered + surface_patio, data=df)
}

propTypes <- propTypes %>% 
  mutate(model = map(data, patio_model))

propTypes
```

```{r}
get_coefficients <- function(mod){
  c <- coef(mod) %>% 
    as.list() %>% 
    as_tibble()
  return(c)
}

propTypes %>% 
  mutate(coeff = map(model, get_coefficients),
         glnc = map(model, glance)) %>% 
  unnest(coeff, glnc, .drop = TRUE)
```

```{r}
summary(propTypes$model[[1]])
summary(propTypes$model[[2]])
summary(propTypes$model[[3]])
```

