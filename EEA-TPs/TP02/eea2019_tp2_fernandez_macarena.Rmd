---
title: "Trabajo Práctico N°2^[El código fuente de este trabajo se encuentra disponible  [aquí](https://github.com/aladaspalabras/EEA2019/tree/master/EEA-TPs/TP01).]"
author: "Macarena Fernandez Urquiza"
output: 
  html_notebook:
    toc: true
    toc_float: true
    depth: 3
---

<style type="text/css">
div.main-container {
  max-width: 1600px;
  margin-left: auto;
  margin-right: auto;
}
body {
text-align: justify}
h1{
  font-size: 19pt
}
h2{
  font-size: 17pt
}
h3{
  font-size: 15pt
}
</style>

```{r, warning=FALSE}
library(tidyverse)
library(OneR)
library(broom)
```

# 1. Regresión Lineal Múltiple

## 1.1. Creación del modelo

Se carga un dataset de propiedades.

```{r}
properties <- read_rds('ar_properties.rds')
```

Éste cuenta con 8 variables:

- _id_
- _l3_ (barrio en el que se ubica la propiedad)
- _rooms_  (cantidad de habitaciones)
- _bathrooms_ (cantidad de baños)
- *surface_total* (superficie total)
- *surface_covered* (superficie cubierta)
- _price_ (precio)
- *property_type* (tipo de propiedad)

Exceptuando la variable _id_ que contiene valores únicos con el fin de identificar las propiedades,
se crea un modelo de Regresión Lineal Múltiple para predecir el precio de cada propiedad a partir de las covariables restantes.

```{r}
modelo <- lm(price ~ l3 + rooms + bathrooms + surface_total + surface_covered + property_type,
            data=properties)

length(unique(properties$l3))
summary(modelo)
```

## 1.2. Análisis del modelo

### 1.2.1. Interpretación de los coeficientes estimados

Según este modelo, -109406.61 es la ordenada al origen. Esto significa que, si encontrásemos una propiedad en la que todas las variables tuviesen un valor igual a 0, el modelo predeciría que dicha propiedad tendría un precio de -109406.61.

El resto de los coeficientes indica cómo varía, según la predicción de nuestro modelo, dicho precio inicial al aumentar en una unidad la variable en cuestión.

En el caso de las variables _l3_ y *property_type*, nos encontramos ante variables dummies, variales categóricas que indican que la propiedad tiene cierta cualidad o no. _l3_ se refiere al barrio donde se ubica la propiedad y *property_type*, al tipo de propiedad en que consiste (PH o departamento).

Dado que una propiedad no puede encontrarse en más de un lugar ni ser de más de un tipo, solo uno de los coeficientes para la variable _l3_ y uno para la variable *property_type* tendrá influencia en la predicción que realice nuestro modelo para cada propiedad. Por ejemplo, en el caso de un departamento de Caballito, nuestro modeo utilizará el coeficiente 6220.15 para la variable _l3_ y el coefciente 92653.32 para *property_type*. El resto de los coeficientes relacionados a _l3_ y a *property_type* no se utilizarán dado que la variable reflejará un valor igual a 0 en dichos casos, dejándolos anulados. 

En particular, se observa que los barrios de Puerto Madero, Las Cañitas, Belgrano, Palermos, Recoleta, Núñez, Barrio Norte, Coghlan, Colegiales, Villa Urquiza, Retiro, Saavedra, Villa Ortúzar, Villa Devoto, Chacarita, Pueyrredń, Caballito, Parque Chas, Villa Crespo y Agronomía influirán positivamente en el precio estimado por el modelo puesto que sus coeficientes son positivos. El resto de los barrios, en cambio, presenta un coeficiente negativo por lo que el valor estimado presentará un decremento si la propiedad se encuentra ubicada en uno de ellos.

Las variables _rooms_, _bathrooms_, *surface_total* y *surface_covered*, por otro lado, son numéricas, y pueden tomar cualquier valor. La multiplicación de sus valores por sus respectivos coeficientes también tendrá un impacto en la predicción de nuestro modelo, ya sea generando un aumento en el precio, en el caso de los baños, la superficie total y la superficie cubierta, o ya sea provocando una disminución, en el caso de los dormitorios.

### 1.2.2. Significatividad de las variables dummies

Resulta interesante destacar que, a excepeción de los barrios de Agronomía, Almagro, Barracas, Caballito, Monte Castro, Parque Chas, San Telmo, Villa Crespo, Villa del Parque, Villa Luro, Villa Real y Santa Rita, los valores de la variable dummy _l3_ presentan un *p-valor* menor a 0.05, lo que significa que la variable es útil para explicar _y_ cuando en el modelo se encuentran presentes las demás variables, pero no en otro caso. Lo mismo sucede con la variable dummy *property_type*.

Los coeficientes calculados para Agronomía y Villa Crespo, por su parte, muestran un valor mayor a 0.7, indicando que en estos casos la variable resulta significativa incluso en ausencia de las demás variables.

### 1.2.3. Evaluación del modelo

Respecto de la evaluación del modelo, podemos ver que este presenta un R² de 0.77, lo que indica que nuestro modelo es capaz de explicar el 77% de la variabilidad de la variable depediente _y_ a partir de las variables independientes proporcionadas.

## 1.3. Predicciones

A continuación, se proponen dos nuevos casos y se utiliza el modelo ajustado para predecir sus precios.

El primer caso consiste en un departamento de 120 metros cuadrados cubiertos, ubicado en el barrio de Abasto, con 3 dormitorios y 2 baños. El segundo se trata de un PH en Balvanera, con 80 metros cuadrados cubiertos, 20 metros cuadrados no cubiertos, 2 dormitorios y 3 baños.

Se genera un nuevo dataset con estos casos y se utiliza la funció _predict_ para predecir sus precios.

```{r}
nuevos_casos <- data.frame(
  l3 = c('Abasto', 'Balvanera'),
  rooms = c(3, 2),
  bathrooms = c(2, 3),
  surface_total = c(120, 100),
  surface_covered = c(120, 80),
  property_type = c('Departamento', 'PH') 
)

nuevos_casos %>% 
  mutate(predict = predict(modelo, newdata = .)) %>% 
  select(l3, predict, everything())
```

El modelo predice que la propiedad en el barrio de Abasto vale 324596.4, mientras que la del barrio de Balvanera cuesta 215267.6, por lo que resulta preferible tener la primera para vender.

## 1.4. Creación de un nuevo modelo

Se crea un nuevo modelo sin la variable _l3_.

```{r}
modelo_sin_l3 <- lm(price ~ rooms + bathrooms + surface_total + surface_covered + property_type,
                   data=properties)

summary(modelo_sin_l3)
```

Se observa que este modelo presenta una mayor cantidad de residuos. Si bien el número observado es menor (-9643) que en el modelo anterior (-3307), lo deseable es que la media y/o mediana de los residuos se acerque a 0.

Por otro lado, si bien los coeficientes estimados han variado su valor, no han cambiado su signo, por lo que su incidencia en la estimación de precios se mantiene: aquellas variables que incrementaban el valor de los precios continuan haciéndolo y lo mismo ocurre con las que disminuían este valor.

Finalmente, se puede que este segundo modelo posee una menor capacidad explicativa de la variable _y_. Su R² nos indica que las variables independientes solo pueden explicar el 68% de la variable dependiente. Este decremento podría resultar esperable en tanto este modelo utiliza menos variables. Los modelos de Regresión Lineal aumentan su R² conforme aumentan la cantidad de variables empleadas en la predicción, sin importar si estas están o no correlacionadas con la variable a predecir. Sin embargo, si observamos el R² ajustado, vemos que también aquí el primer modelo supera al segundo (77% contra 68%). Esto resulta relevante puesto que el R² ajustado indica la capacidad de explicación de un modelo considerando las variables independientes que sí se encuentran relacionadas con la dependiente. Esta medida disminuya al añadir variables no relacionadas y aumneta solo si las variables agregadas son efecitvamente explicativas. Debido a esto, el R² ajustado posibilita la comparación de modelos con distinta cantidad de variables y será el que utilizaremos para determinar qué modelo explica mejor la variable precios.

## 1.5. Comparación de modelos

El modelo que mejor explica la variable precios es el modelo que incluye la variable _l3_, dado que su R² ajustado. El modelo sin esta variable presenta una menor capacidad de explicación, solo el 68% de la variabilidad de la variable dependiente.

# 2. Creación de variables

## 2.1. Variable _barrios_

Con el propósito de crear una nueva variable _barrios_ de tipo categórica que distinga entre barrios con precio _alto_, _medio_ y _bajo_, se grafica un scatter plot de precios que nos permita visualizar si existen puntos críticos capaces de funcionar como puntos de corte entre las categorías definidas.

```{r}
plot(sort(properties$price, decreasing = FALSE),
     main  = 'Precios ordenados en forma creciente',
     ylab = 'Precios',
     xlab = 'Índice',
     col = 'cyan4')
```

Dado que no se observa la presencia de tales puntos, se opta por generar 3 bins de manera automática utilizando el método de "clusters" de la función _bin_ del paquete _OneR_. Para ello, primero se agrupan los precios por barrios y se calcula su media, este será el input que tomará la función.

```{r}
precios <- properties %>% 
  select(l3, price) %>% 
  group_by(l3) %>% 
  summarise(media_precio = mean(price)) %>% 
  arrange(media_precio)

precios
```


```{r}
precios$clusters <- bin(precios$media_precio,
                        nbins=3, 
                        labels=c("bajo", "medio", "alto"), 
                        method="clusters")

precios
```

Dado que deseamos tener clases balanceadas, revisamos cuántos barrios han quedado agrupados en cada clase.

```{r}
precios %>% 
  count(clusters)
```

Vemos que no se han obtenido clases balanceadas. La categoría _bajo_ cuenta con muchos más barrios que las otras dos. Y la categría _alto_ agrupa un único barrio. 

Volvemos a generar los bins pero ahora utilizamos el método de _content_, que arma bins con igual cantidad de elementos.

```{r}
precios$bins <- bin(precios$media_precio, 
                    nbins=3, 
                    labels=c("bajo", "medio", "alto"), 
                    method="content")

precios
```

Chequeamos para confirmar:

```{r}
precios %>% 
  count(bins)
```

Agregamos la nueva información al data frame de datos que ya teníamos. Para ello, utilizamos la función *left_join*. Además, cambiamos el nombre de la nueva variable _bins_ por _barrios_.

```{r}
properties_barrios <- left_join(properties, precios[,c('l3', 'bins')], by='l3')
names(properties_barrios)[names(properties_barrios) == 'bins'] <- 'barrios'

properties_barrios
```

## 2.2. Modelo con variable _barrios_

Se ajusta un nuevo modelo. Esta vez, se utiliza la variable _barrios_ creada en el apartado anterior en lugar de la variable _l3_.

```{r}
model_con_barrios <- lm(price ~ rooms + bathrooms + surface_total + surface_covered +
                          property_type + barrios, data=properties_barrios)

summary(model_con_barrios)
```

Es posible notar que la mediana de los residuos de este modelo presenta signo negativo, al igual que el modelo que incluía a la variable _l3_. Esto nos indica que al menos la mitad de los valores Ŷ predichos por ambos modelos son valores que se encuentran por encima de los valores Y observados.
No obstante, la mediana de los residuos de este segundo modelo se encuentra más cerca del 0 que la mediana del modelo con _l3_, lo que podría indicar una menor distancia entre los valores Ŷ predichos en este caso y los valores Y reales.

En cuanto a los coeficientes calculados, podemo observar que, si bien sus valores han cambiado, no lo ha hecho así si signo. Lo que nos implica que aquellas variables que influían positivamente en la variable a predecir lo siguen haciendo y lo mismo ocurre con la variable _rooms_, cuya incidencia era negativa.

Por último, notamos que la variabilidad explicada por este modelo es del 73% (valor de R²). Sin embargo, como ya se advirtió previamente, no debemos fiarnos de esta medida para establecer una comparación con el modelo de _l3_, sino que debemos utilizar su valor ajustado. Dado que el R² ajustado de este modelo resulta menor que el del modelo de _l3_ (73% contra 77%), podemos afirmar que es ete último el modelo que mejor explica la variabilidad de los datos.

De todos modos, cabe hacer la reflexión de qué modelo resulta más útil a la hora de estimar el precio de una propiedad. Si bien el modelo de _l3_ explica mejor a la variable Y, la cantidad de valores posibles posibles que puede adoptar la variable _l3_ y sus correspondientes coeficientes (igualmente variados) no permiten establecer un patrón claro que dé cuenta de cómo influye esta variable en la predicción. El modelo ajustado con la variable _barrios_, en cambio, si bien posee un menor poder explicativo, sí nos da una idea de esta relación: en todos los casos en los que la propiedad se encuentre ubicada en un barrio de precio "medio", el valor predicho de la misma aumentará 20501,46, y en los casos en los que se ubique en un barrio de precio "alto", el valor se incrementará en 76571,89.

## 2.3. Variable *surface_patio*

Dado que las variable *surface_covered* y *surface_total* están correlacionadas, se propone crear una nueva variable llamada *surface_patio*  que refleje la diferencia entre ambas superficies. De este modo:

surface_patio = surface_total - surface_patio

Sin embargo, podría ocurrir que se encontrasen casos de inconsistencia donde la superficie total de una vivienda fuese menor a su superficie cubierta. De encontrarse tales casos, se propone eliminarlos, puesto que se trataría de registros mal ingresados. 

Entonces, como primer paso, se chequea la existencia de casos de inconsistencia.

```{r}
nrow(properties_barrios[properties_barrios$surface_covered > properties_barrios$surface_total,])
```

No se observan casos en los que la superficie total sea menor que la cubierta. Se procede a generar la nueva variable previamente definida.

```{r}
properties_barriosYpatio <- properties_barrios %>% 
  mutate(surface_patio = surface_total-surface_covered)

properties_barriosYpatio
```

## 2.4. Modelo con la variable *surface_patio*

Se entrena un nuevo modelo utilizando ahora la variable _barrios_ en lugar de _l3_ y la variable *surface_patio* en lugar de *surface_total*.

```{r}
modelo_barriosYpatio <- lm(price ~ barrios + rooms + bathrooms + surface_covered + surface_patio +
                          property_type, data=properties_barriosYpatio)

summary(modelo_barriosYpatio)
```
surface_patio: mismo coeficiente que surface_total...

# 3. Evaluación de modelo

Analizar los residuos del modelo elaborado en 2.d

## 3.1. Modelo alternativo

Comparar la performance del modelo de 2.d con éste, tanto en términos de la variabilidad explicada cómo de su relación con los supuestos del modelo lineal. Re-interpretar los parámetros del modelo.

```{r}
model_log = lm(price ~ log(rooms) + log(bathrooms) + log(surface_covered) + property_type + 
                 barrios + surface_patio, data=properties_barriosYpatio)

summary(model_log)
```

# 4. Modelos por tipo de propiedad

Anido el dataframe por la variable *property_type*.

```{r}
propTypes <- properties_barriosYpatio %>% 
  group_by(property_type) %>% 
  nest()

propTypes
```

Para cada tipo de propiedad, genero el modelo de 2d

```{r}
patio_model <- function(df) {
  lm(price ~ barrios + rooms + bathrooms + surface_covered + surface_patio, data=df)
}

propTypes <- propTypes %>% 
  mutate(model = map(data, patio_model))

propTypes
```

```{r}
get_coefficients <- function(mod){
  c <- coef(mod) %>% 
    as.list() %>% 
    as_tibble()
  return(c)
}

propTypes %>% 
  mutate(coeff = map(model, get_coefficients),
         glnc = map(model, glance)) %>% 
  unnest(coeff, glnc, .drop = TRUE)
```

```{r}
summary(propTypes$model[[1]])
summary(propTypes$model[[2]])
summary(propTypes$model[[3]])
```

